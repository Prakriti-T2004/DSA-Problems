# Leetcode
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (a,b) -> {
            if(a[0] != b[0]) return a[0] - b[0];
            return b[1] - a[1]; 
            
        });
    
        int n = envelopes.length;
        int[] height = new int[n];
        for(int i=0; i<n; i++){
            height[i] = envelopes[i][1];
        }
        return lis(height);
    }
    public int lis(int[] arr){
        ArrayList<Integer> temp = new ArrayList<>();
        temp.add(arr[0]);
        for(int i=1; i<arr.length; i++){
            if(arr[i] > temp.get(temp.size()-1)){
                temp.add(arr[i]);
            }
            else{
                temp.set(lowerBound(temp, arr[i]), arr[i]);
            }
        }
        return temp.size();
    }
    public int lowerBound(ArrayList<Integer> temp, int target){
        int low = 0;
        int high = temp.size() - 1;
        while(low <= high){
            int mid = low + (high - low)/2;
            if(temp.get(mid) == target){
                return mid;
            }
            else if(temp.get(mid) < target){
                low = mid+1;
            }
            else{
                high = mid-1;
            }
        }
        return low;
    }
}

/* why we are sorting height in descending order?

If sorted as [[6,4], [6,7]] (height asc), heights sequence is [4, 7] → LIS can take both 4 and 7, but widths are equal, so this is invalid nesting.

Sorting as [[6,7], [6,4]] (height desc) gives heights [7, 4] → LIS cannot take both (7 then 4 is not increasing), so only one of them can be part of the subsequence, which is correct.
*/
