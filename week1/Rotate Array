class Solution {
    /* Brute Force approach
    *Time complexity: n*k , space complexity: O(1)
    *Idea: rotate the array one step at a time and for each rotation, take the last element*/ 

    public void rotate1(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        for(int i=0; i<k; i++){
            int temp = nums[n-1];
            for(int j=n-1; j>0; j--){
                nums[j] = nums[j-1];
            }
            nums[0] = temp;
        }
    }


    /*Approach 2: Extra Array
    *Time complexity:O(n) , Space compexity: O(n)
    *Idea: 1.copy the last element to a new array.
           2.copy the first n-k element after them and copy everything back to original nums.*/

    public void rotate2(int[] nums, int k){
        int n = nums.length;
        k = k % n;
        int[] arr = new int[n];
        int i = 0;

        //copy last k elements
        for(int j=n-k; j<n; j++){
            arr[i++] = nums[j];
        }

        //copy first n-k elements
        for(int j=0; j<n-k; j++){
            arr[i++] = nums[j];
        }
        
        //copy back to nums
        for(int j=0; j<n; j++){
            nums[j] = arr[j];
        }
    }

    /*Approach 3: Optimize solution(Reverse method)
    *time complexity = O(n), space complexity = O(1)
    *Idea: 1. Reverse the entire array
           2. Reverse first k elements and then reverse the remaining n-k elements.*/

    public void rotate(int[] nums, int k){
        int n = nums.length;
        k = k % n;
        reverse(nums, 0, n-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, n-1);
    }
    
        // helper function to reverse elements between indices l and r
    private void reverse(int[] nums, int l, int r){
        while(l < r){
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }
        
    
}
